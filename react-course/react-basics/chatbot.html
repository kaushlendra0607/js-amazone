<!DOCTYPE html>
<html>

<!-- really inportant thing 
we should generally use debounce hook gpt for more 
debounce is for search optimisation -->
<head>
    <title>Chatbot</title>
    <style>
        body{
            font-family: Arial, Helvetica, sans-serif;
            box-sizing: border-box;
            margin: 0 8px;
        }
        .send-button {
            background-color: rgb(25, 135, 84);
            /* width: 100px;
            height: 50px; */
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            margin: 10px;
            color: white;
            box-sizing: border-box;
            border: none;
            cursor: pointer;
        }

        .chat-input {
            padding: 20px 14px;
            font-size: 14px;
            height: 36px;
            border: 2px solid #aaa;
            border-radius: 8px;
            box-sizing: border-box;
            outline: none;
            background-color: #fff;
            color: #333;
            transition: border 0.25s ease, box-shadow 0.25s ease;
            flex-grow: 1;
        }

        .chat-input::placeholder{
             color: #999;
        }
        .chat-input:focus {
            border: 2px solid transparent;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            background-image:
                linear-gradient(#fff, #fff),
                linear-gradient(120deg, #ff00cc, #3333ff, #00ffff);
            animation: animated-outline 2s linear infinite;
            outline: none;
            background-size: 200% 200%;
            background-position: 0% 50%;
        }

        @keyframes animated-outline {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }
        .chat-input-container{
            display: flex;
            align-items: center;
            margin-bottom: 40px;
        }
        .app-container{
            max-width: 600px;
            margin: auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .initial-message{
            text-align: center;
            margin-top: 20px;
            opacity: .5;
            font-size: large;
        }
        .chat-message-user{
            display: flex;
            justify-content: end;
            align-items: center;
        }
        .chat-message-robot{
            display: flex;
            align-items: center;
        }
        .chat-message-text{
            background-color: rgb(232, 232, 232);
            padding: 15px 20px;
            margin: 10px 10px;
            border-radius: 10px;
            max-width: 300px;
        }
        .chat-message-profile{
            width:45px;
        }
        .chat-messages-container{
            flex-grow: 1;
            margin-top: 20px;
            overflow: scroll;
            scrollbar-width: none;
        }
        
    </style>
</head>

<body>
    <div class="js-container"></div>

    <script src="https://unpkg.com/supersimpledev/react.js"></script>
    <script src="https://unpkg.com/supersimpledev/react-dom.js"></script>

    <script src="https://unpkg.com/supersimpledev/chatbot.js"></script>
    <script src="https://unpkg.com/supersimpledev/babel.js"></script>
    <script type="text/babel">//In React each word of a component should start with capital letter(Pascal Case)
        function ChatInput({ chatMessages, setChatMessages }) {//now we can access this state from our own created attributes
            const [inputText, setInputText] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);
            function saveInputText(event) {//event is an object which contains the properties of onchange element.
                setInputText(event.target.value);//used as a funcn will update the data and the html both
            }

           async function sendMessage() {
                if (isLoading || inputText === '') {
                    return;//if isLoading is true which means the chatbot is still processing a previous message (waiting for the botâ€™s response).This prevents from sending another message when the bot hasnt replied yet
                }//if inputText === '' means the input box is empty This stops sending empty messages (which would be pointless).
                 // Set isLoading to true at the start, and set it to
                 // false after everything is done.
                 setIsLoading(true);
                const newChatMessages = [//here we're first spreading the old messages and then actually adding the new messages after it as well into the array and the old array is safe which is chatMessages
                    ...chatMessages,//syntax of spread oprtr
                    {//this the new data to be updated
                        message: inputText,//inputText will be the new data updated by the function saveInputText above
                        sender: "user",
                        id: crypto.randomUUID()
                    }
                ];
                setChatMessages([
                   ...newChatMessages,
                     // This creates a temporary Loading... message.
                    // Because we don't save this message in newChatMessages,
                    // it will be remove later, when we add the response.
                     {
                        message: <img src="../chatbot-project/src/assets/loading-spinner.gif" alt="Loading..." style={{width:'40px',margin:'-15px'}} />,
                        sender: 'robot',
                        id: "loading-message"
                    }
                ]);//we're explicitly using setChatMessages unlike right below bcz State doesn't updates the old data until the code is finished or html is rendered
                 // We can put this here or at the top of this function
                // (clear the textbox immediately after clicking Send).
                // Both solutions work.
                setInputText('');
                const response = await Chatbot.getResponseAsync(inputText);
                setChatMessages([//will update the data and the html both
                    // This makes a copy of newChatMessages, but without the
                    // last message in the array.
                    ...newChatMessages.filter(msg => msg.id !== "loading-message"),//we're not using chatMessages bcz code needs to be finished for updation of old data Instead we're using newChatmessages which finishes the code first and then updates the chatmessages
                    {//this the new data to be updated
                        message: response,
                        sender: "robot",
                        id: crypto.randomUUID()
                    }
                ]);
                 // Set isLoading to false after everything is done.
                 setIsLoading(false);
                
            }
            function sendOnEnter(event){
                if(event.key === 'Enter'){//this will send the message on enter
                    sendMessage();
                    setInputText('');
                }
                if(event.key === 'Escape'){
                   setInputText('');
                }
            }

            return (
                <div className="chat-input-container">
                    <input
                        type="text"
                        placeholder="Send message to Chatbot"
                        onChange={saveInputText}//dont put parenthesis over here.React will provide argument itself on some change
                        value={inputText}//we're puting the value of input to inputText and after sending a message value of inputText is updated to empty string above in sendMessage funcn by setInputText so the input box will become empty after sending a message. It is called a controlled input
                        className="chat-input"
                        onKeyDown={sendOnEnter}
                    />
                    <button onClick={sendMessage} className="send-button">Send</button>
                </div>
            );
        }
        function ChatMessage({ message, sender }) {//passing the attributes directly here is the shortcut for const {message,sender}=props;
            //const message = props.message;every funcn which is made an html element gets an object by itself generally called props which has the attributes or properties defined in it
            //const sender=props.sender;
            //const {message,sender}=props;
            /*
            if(sender === "robot"){
                return (
                    <div>
                        <img src="robot.png" alt="robot" width="50" />
                        {message}
                    </div>
                );
            }*/
            return (
                <div className={sender === "user" ? "chat-message-user":"chat-message-robot"}>
                    {sender === "robot" && <img src="robot.png" alt="robot" className="chat-message-profile" />}
                    <div className="chat-message-text">{/*in AND operator if first one is true then the ans is second one*/}
                       {message}{/*this is like a plain text inserted here just the difference will be that it will be updated dynamically lke using dom in js*/}
                    </div>
                    {sender === "user" && <img src="user.png" alt="user" className="chat-message-profile"/>}
                </div>
            );
        }

         // To use a function as a hook, the function name must
        // start with "use".
        function useAutoScroll(dependencies){
             const containerRef = React.useRef(null);
             React.useEffect(()=>{
                const containerElem = containerRef.current;
                if (containerElem) {
                    containerElem.scrollTop = containerElem.scrollHeight;
                }
             },dependencies);
             return containerRef;
        }

        function ChatMessages({ chatMessages }) {//using state will change the html as well when the data changes.
            // const chatMessages = array[0];//array[0] gives the current data from state.
            // const setChatMessages = array[1];//this is actually a function and has to be treated xactly like a funcn. this updates the data in future.
            // const [ chatMessages, setChatMessages] = array;//shortcut for above two lines(order matters of chatMessages and setChatMessages)on useState line shortest method is used for destructuring.

            /* function sendMessage(){
                 chatMessages.push({
                     message:"test",
                     sender:"user",
                     id:crypto.randomUUID()
                 });
                 console.log(chatMessages);
                 the above method is modifying the data directly.Not good practice 
                 we shuld modify the copy of  the data.Use useState...
                  }*/
            // const chatMessagesRef=React.useRef(null);//useRef lets us save an html element ,basically works like queryselector
            // React.useEffect(()=>{//useEffect lets us run some code after a component is created or updated
            // const containerElem = chatMessagesRef.current;
            // if(containerElem){
            //     containerElem.scrollTop=containerElem.scrollHeight;
            //     //scrollTop is how far is scroll from the top and scrollHeight is total scroling height of the element so if we set the scrollTop equal to Height then it will get on bottom...
            // }
               
            // },[chatMessages]);//the array provided here controls the times useEffect runs go chatgpt for more
            const chatMessagesRef = useAutoScroll([chatMessages]);
            return (//a function can only return one element at a time so for multiple elements enclose them in a div
                <div className="chat-messages-container"
                ref={chatMessagesRef}
                >
                    {
                        chatMessages.map((chatMessage) => {
                            return (
                                <ChatMessage
                                    message={chatMessage.message}
                                    sender={chatMessage.sender}
                                    key={chatMessage.id}
                                />
                            );
                        })
                    }
                </div>
            );
        }

        function App() {
            const [chatMessages, setChatMessages] = React.useState([]);
            if (chatMessages.length===0){
                return(
                    <div className="app-container">
                    <div className="initial-message">Welcome to chatbot Project.Send a message using textbox below</div>
                    <ChatMessages chatMessages={chatMessages} />
                    <ChatInput chatMessages={chatMessages} setChatMessages={setChatMessages}/>
                    </div>
                )
            }
            //we removed above code from ChatMessages funcn to its parent component i.e. App this makes the availability of state to all the child component of App and this process is called lifting the state up . We did it so that ChatInput can use it as well
            return (
                <div className="app-container">{/*Here we now add some props (attributes) to our created element ChatInput */}
                    
                    <ChatMessages chatMessages={chatMessages} />
                    {/*we generally use same name as above.<></>this oprtr is generally termed as fragment, it desnt adds more divs in the html*/}
                    <ChatInput //here we created our own html element. One way to do this is use <></> and run the funcn inside using {} but this is the shorter way
                        chatMessages={chatMessages}//here we created our own attributes
                        setChatMessages={setChatMessages}//these attributes are passed in an object to the ChatInput funcn
                    />{/*the two above values have been lifted up to App compo. from ChatMessages compo. so they can be used by ChatInput compo.*/}
                </div>
            );
        }

        const container = document.querySelector('.js-container');
        ReactDOM.createRoot(container).render(<App />);
    </script>


</body>

</html>